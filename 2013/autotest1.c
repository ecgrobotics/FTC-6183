#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     HTPB,           sensorI2CCustom9V)
#pragma config(Sensor, S3,     light,          sensorCOLORFULL)
#pragma config(Sensor, S4,     ir,             sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     left,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     right,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     arm,           tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    latch,                tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//TODO account for forward IR bias on 1 and 2 and backward ir bias for 3 and 4....
//yes its bs. the damned ir beacons arent centered under the baskets

//NOTE: if compilation and running fails, set general preference for multi-robot to false
#include "HTPB.h"
#define PRIMARY_ROUTE 1
#define SECONDARY_ROUTE 2
#define ERROR 2
bool getSwitch();
void drive(int pwr);
void rotateRight(int degrees, int pwr);
void rotateLeft(int degrees, int pwr);
void forwardFromWall();
void driveUntilIR(int pwr);
void dump();
void driveForwardToWall(int pwr);
void driveBackwardToWall(int pwr);
void driveToLine(int pwr);
void driveOntoRamp(int pwr);

task gyroThread;
task graphicsThread;

volatile float theta=0;
volatile int updateTime=5;
volatile int sonar1;
volatile int sonar2;
volatile int sonar3;
int stationaryVoltage=515;
/*HTPB:	310/V=.310/mV;
 *Gyro: 7mV/degree/s=.007V/degree/s
 *Gyro with resistors:  (2/3) everything, 4.66666mV/degree/s = .0046666V/degree/s
 *NXT: 1.446/2 /degree/sec   idk where the /2 cam from, but it works....
 */
const float valueDegreeSecond=1.446/2;//for FRC gyro analog conversion...//changed from 1.449 to 1.446: previous value would cause it to be off by .6 degrees/second/second
const int colorThreshold=40;
const int sonar1Stage1=30;
const int sonar2Stage3B=10;
const int sonar3Stage3A=10;

//check light differences between field and ramp
//COLLECT CONSTANTS:
bool data=false;//if collecting sonar data
bool useLight=true;
bool useSonars=false;
int path=SECONDARY_ROUTE;
void init(){

	nMotorEncoder[arm]=0;
		int sum=0;
		for(int i=0;i<5;i++){
			sum+=readAnalogInput(HTPB,0);
			wait1Msec(100);
		}
		stationaryVoltage=sum/5;
}
task main()
{
		init();
		wait1Msec(500);
		//dump();
	//	wait1Msec(1000000);

		StartTask(gyroThread);
		wait1Msec(1000000);
		forwardFromWall();
		rotateRight(45,50);
		driveUntilIR(20);
		if(data){
				while(nNxtButtonPressed!=kEnterButton);
		}
		else{
			dump();
			wait1Msec(250);
  	}
		if(path==PRIMARY_ROUTE){
				driveForwardToWall(40);
				wait1Msec(250);
				rotateLeft(90,40);
				wait1Msec(250);
				driveToLine(30);
				wait1Msec(500);
				rotateLeft(90,40);
				wait1Msec(500);
				driveOntoRamp(50);
		}
		else if(path==SECONDARY_ROUTE){
				driveBackwardToWall(40);
				wait1Msec(500);
				rotateLeft(90,40);
				wait1Msec(250);
				driveToLine(30);
				wait1Msec(500);
				rotateRight(90,40);
				wait1Msec(500);
				driveOntoRamp(50);
		}
}
void drive(int pwr){
	motor[right]=-pwr;
	motor[left]=pwr;
}
bool getSwitch(){
	ubyte b=HTSPBreadIO(HTPB,0b00000010);

	return (1<<6 & b) ? 1 :0;
}
void forwardFromWall(){
	//TODO SONAR 1
		drive(40);
		if(useSonars){
			while(sonar1<sonar1Stage1);
  	}
		else wait1Msec(440);
		drive(-40);
		wait1Msec(200);
		drive(0);
}
void driveUntilIR(int pwr){
		drive(pwr);
		while(SensorValue[ir]!=5);
		drive(-30);
		wait1Msec(175);
		drive(0);
		//TODO analyze sonars
}
void dump(){
		motor[arm]=-15;
		while(nMotorEncoder[arm]>-590){
			nxtDisplayCenteredBigTextLine(3,"%d", nMotorEncoder[arm]);
		}//TODO check this
		motor[arm]=15;
		wait1Msec(50);
		motor[arm]=0;
		wait1Msec(1000);
		servo[latch]=180;
		wait1Msec(500);
		servo[latch]=255;
		motor[arm]=15;
		while(nMotorEncoder[arm]<100);
		motor[arm]=0;
		/*servo[latch]=255;
		motor[arm]=20;
		while(nMotorEncoder[arm]<-30);
		motor[arm]=0;
		*/
}
void driveForwardToWall(int pwr){
		drive(pwr);
		if(useSonars)while(sonar3>sonar3Stage3A);
		else wait1Msec(1300);
		drive(0);
}
void driveBackwardToWall(int pwr){
		drive(-pwr);
		if(useSonars)while(sonar2>sonar2Stage3B);
		else wait1Msec(2000);
		drive(0);
}
void driveToLine(int pwr){
		drive(pwr);
		if(useLight){
		//	while(SensorValue[light]<2);
		while(readAnalogInput(HTPB,1)<3);
		}
		else wait1Msec(1300);
		drive(0);
}
void driveOntoRamp(int pwr){
		drive(pwr);
		wait1Msec(1500);
		drive(0);
}
//TODO improve this and use better motors on drive train to prevent drift
void rotateRight(int degrees, int pwr){
		float itheta=theta;
		hi:
		motor[left]=pwr;
		motor[right]=pwr;
		while(theta-itheta<degrees-10);
		motor[left]=0;
		motor[right]=0;
		wait1Msec(200);
	//	if(theta-itheta<degrees)goto hi;
		motor[left]=-20;
		motor[right]=-20;
		while(theta-itheta>degrees);
		motor[left]=0;
		motor[right]=0;
}
void rotateLeft(int degrees, int pwr){
		float itheta=theta;
		hi:
		motor[left]=-pwr;
		motor[right]=-pwr;
		while(itheta-theta<degrees-10);
		motor[left]=0;
		motor[right]=0;
		wait1Msec(200);
		//if(itheta-theta<degrees)goto hi;
		motor[left]=20;
		motor[right]=20;
		while(itheta-theta>degrees);
		motor[left]=0;
		motor[right]=0;
}
void rotateRightv2(int degrees){
		float itheta=theta;
		motor[left]=35;
		motor[right]=35;
		while(theta-itheta<degrees-10);
		motor[left]=0;
		motor[right]=0;
		goto check;
		moreleft:
			motor[left]=-20;
			motor[right]=-20;
			while(theta-itheta>degrees+ERROR);
			motor[left]=0;
			motor[right]=0;
			goto check;
		moreright:
			motor[left]=20;
			motor[right]=20;
			while(theta-itheta<degrees-ERROR);
			motor[left]=0;
			motor[right]=0;
			goto check;
		check:
			wait1Msec(100);
			if(theta-itheta>degrees+1)goto moreleft;
			if(theta-itheta<degrees-1)goto moreright;
			motor[left]=0;
			motor[right]=0;
}
task graphicsThread(){
		while(true){
				if(!data)nxtDisplayCenteredBigTextLine(0,"%d",theta);
				else nxtDisplayCenteredBigTextLine(0,"IR: %d",SensorValue[ir]);
			//	nxtDisplayCenteredBigTextLine(2,"%d ms",updateTime);
				nxtDisplayCenteredBigTextLine(2,"%d",sonar1);
				nxtDisplayCenteredBigTextLine(4,"%d ms",sonar2);
				nxtDisplayCenteredBigTextLine(6,"%d",sonar3);
				wait1Msec(100);
		}
}
task gyroThread(){
		StartTask(graphicsThread);
		ClearTimer(T4);
		while(true){
				int v=0;
				HTSPBreadAllADC(HTPB,v,sonar1,sonar2,sonar3,10);
				v=readAnalogInput(HTPB,0);
				float dv=v-stationaryVoltage;
				float dtheta=dv*valueDegreeSecond;
				theta+=dtheta*time1[T4]*.001;
				updateTime=time1[T4];
				ClearTimer(T4);
				wait1Msec(2);
		}
}
